'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.trimWordSpacing = trimWordSpacing;
exports.getAllLineStart = getAllLineStart;
exports.mapLocToRange = mapLocToRange;
exports.replaceComment = replaceComment;
/**
 * trim all invisiable char between words expect the last blank
 * @param {*sting} text
 */
function trimWordSpacing() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    return text.trim().replace(/[\s]/g, ' ').replace(/\s+/g, ' ');
}

/**
 * get all line start position in text
 * @param {*string} text
 */
function getAllLineStart() {
    var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

    var lineStart = [0];
    var position = 0;
    while (position < text.length - 1) {
        if (text[position] === '\r' || text[position] === '\n') {
            if (text[position] === '\r' && text[position + 1] === '\n') {
                position += 2;
                if (position < text.length) {
                    lineStart.push(position);
                }
            } else {
                position += 1;
                lineStart.push(position);
            }
        } else {
            position += 1;
        }
    }
    return lineStart;
}

function findPosition(line, lineStart, position) {
    var index = line;
    while (index < lineStart.length - 1) {
        if (lineStart[index + 1] > position) {
            return {
                line: index,
                column: position - lineStart[index]
            };
        }
        index += 1;
    }
    return {
        line: index,
        column: position - lineStart[index]
    };
}

/**
 * map range style to location style in text
 * @param {*list} lineStart
 * @param {*number} startPosition
 * @param {*number} endPosition
 */
function mapLocToRange(lineStart, startPosition, endPosition) {
    var start = findPosition(0, lineStart, startPosition);
    var end = findPosition(start.line, lineStart, endPosition);
    return {
        start: start,
        end: end
    };
}

/**
 * replace all comment in text and do no change feedline and range of import statement's location
 * @param {*string} originText
 * @param {*comments} comments
 */
function replaceComment(originText, comments) {
    var text = originText;
    comments.forEach(function (comment) {
        var startText = text.slice(0, comment.range.start);
        var endText = text.slice(comment.range.end);
        if (comment.type === 'LineComment') {
            var middle = ' '.repeat(comment.range.end - comment.range.start);
            text = startText.concat(middle, endText);
        } else {
            var _middle = ' '.repeat(comment.range.end - comment.range.start - (comment.loc.end.line - comment.loc.start.line)).concat('\n'.repeat(comment.loc.end.line - comment.loc.start.line));
            text = startText.concat(_middle, endText);
        }
    });
    return text;
}